Description: 9p: take write lock on fid path updates
 This patch is a combination of upstream commits 5b76ef50f62079a and
 5b3c77aa581ebb2.
 .
 5b76ef50f62079a:
  The assumption that the fid cannot be used by any other operation is
  wrong. At least, nothing prevents a misbehaving client to create a
  file with a given fid, and to pass this fid to some other operation
  at the same time (ie, without waiting for the response to the creation
  request). The call to v9fs_path_copy() performed by the worker thread
  after the file was created can race with any access to the fid path
  performed by some other thread. This causes use-after-free issues that
  can be detected by ASAN with a custom 9p client.
  .
  Unlike other operations that only read the fid path, v9fs_co_open2()
  does modify it. It should hence take the write lock.
 5b3c77aa581ebb2:
  Recent commit 5b76ef50f62079a fixed a race where v9fs_co_open2() could
  possibly overwrite a fid path with v9fs_path_copy() while it is being
  accessed by some other thread, ie, use-after-free that can be detected
  by ASAN with a custom 9p client.
  .
  It turns out that the same can happen at several locations where
  v9fs_path_copy() is used to set the fid path. The fix is again to
  take the write lock.
 .
 This patch addresses CVE-2018-19364.
Author: Greg Kurz <groug@kaod.org>
Origin: upstream, https://git.qemu.org/?p=qemu.git;a=commit;h=5b76ef50f62079a2389ba28cacaf6cce68b1a0ed
                  https://git.qemu.org/?p=qemu.git;a=commit;h=5b3c77aa581ebb215125c84b0742119483571e55
--- a/hw/9pfs/cofile.c	2019-01-19 19:04:30.113563201 +0100
+++ b/hw/9pfs/cofile.c	2019-01-24 09:33:59.731530333 +0100
@@ -138,10 +138,10 @@
     cred.fc_gid = gid;
     /*
      * Hold the directory fid lock so that directory path name
-     * don't change. Read lock is fine because this fid cannot
-     * be used by any other operation.
+     * don't change. Take the write lock to be sure this fid
+     * cannot be used by another operation.
      */
-    v9fs_path_read_lock(s);
+    v9fs_path_write_lock(s);
     v9fs_co_run_in_worker(
         {
             err = s->ops->open2(&s->ctx, &fidp->path,
--- a/hw/9pfs/virtio-9p.c	2019-01-24 09:26:05.113577885 +0100
+++ b/hw/9pfs/virtio-9p.c	2019-01-24 09:40:01.588611941 +0100
@@ -1323,7 +1323,9 @@
     }
     if (fid == newfid) {
         BUG_ON(fidp->fid_type != P9_FID_NONE);
+        v9fs_path_write_lock(s);
         v9fs_path_copy(&fidp->path, &path);
+        v9fs_path_unlock(s);
     } else {
         newfidp = alloc_fid(s, newfid);
         if (newfidp == NULL) {
@@ -2069,6 +2071,7 @@
     V9fsString extension;
     int iounit;
     V9fsPDU *pdu = opaque;
+    V9fsState *s = pdu->s;
 
     v9fs_path_init(&path);
     v9fs_string_init(&name);
@@ -2109,7 +2112,9 @@
         if (err < 0) {
             goto out;
         }
+        v9fs_path_write_lock(s);
         v9fs_path_copy(&fidp->path, &path);
+        v9fs_path_unlock(s);
         err = v9fs_co_opendir(pdu, fidp);
         if (err < 0) {
             goto out;
@@ -2125,7 +2130,9 @@
         if (err < 0) {
             goto out;
         }
+        v9fs_path_write_lock(s);
         v9fs_path_copy(&fidp->path, &path);
+        v9fs_path_unlock(s);
     } else if (perm & P9_STAT_MODE_LINK) {
         int32_t ofid = atoi(extension.data);
         V9fsFidState *ofidp = get_fid(pdu, ofid);
@@ -2143,7 +2150,9 @@
             fidp->fid_type = P9_FID_NONE;
             goto out;
         }
+        v9fs_path_write_lock(s);
         v9fs_path_copy(&fidp->path, &path);
+        v9fs_path_unlock(s);
         err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);
         if (err < 0) {
             fidp->fid_type = P9_FID_NONE;
@@ -2181,7 +2190,9 @@
         if (err < 0) {
             goto out;
         }
+        v9fs_path_write_lock(s);
         v9fs_path_copy(&fidp->path, &path);
+        v9fs_path_unlock(s);
     } else if (perm & P9_STAT_MODE_NAMED_PIPE) {
         err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,
                             0, S_IFIFO | (perm & 0777), &stbuf);
@@ -2192,7 +2203,9 @@
         if (err < 0) {
             goto out;
         }
+        v9fs_path_write_lock(s);
         v9fs_path_copy(&fidp->path, &path);
+        v9fs_path_unlock(s);
     } else if (perm & P9_STAT_MODE_SOCKET) {
         err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, -1,
                             0, S_IFSOCK | (perm & 0777), &stbuf);
@@ -2203,7 +2216,9 @@
         if (err < 0) {
             goto out;
         }
+        v9fs_path_write_lock(s);
         v9fs_path_copy(&fidp->path, &path);
+        v9fs_path_unlock(s);
     } else {
         err = v9fs_co_open2(pdu, fidp, &name, -1,
                             omode_to_uflags(mode)|O_CREAT, perm, &stbuf);
