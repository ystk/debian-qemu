From 1ae3f2f178087711f9591350abad133525ba93f2 Mon Sep 17 00:00:00 2001
From: Gerd Hoffmann <kraxel@redhat.com>
Date: Mon, 18 Apr 2016 09:11:38 +0200
Subject: [PATCH] ehci: apply limit to iTD/sidt descriptors
MIME-Version: 1.0
Content-Type: text/plain; charset=utf8
Content-Transfer-Encoding: 8bit

Commit "156a2e4 ehci: make idt processing more robust" tries to avoid a
DoS by the guest (create a circular iTD queue and let qemu ehci
emulation run in circles forever).  Unfortunately this has two problems:
First it misses the case of siTDs, and second it reportedly breaks
FreeBSD.

So lets go for a different approach: just count the number of iTDs and
siTDs we have seen per frame and apply a limit.  That should really
catch all cases now.

Reported-by: æå°å <dushaobo@360.cn>
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>

Origin: ubuntu, https://launchpad.net/ubuntu/+source/qemu/2.0.0+dfsg-2ubuntu1.43
Bug-Debian: https://bugs.debian.org/822344
Reviewed-by: Santiago R.R. <santiagorr@riseup.net>
---
 hw/usb/hcd-ehci.c |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)

Index: qemu-2.0.0+dfsg/hw/usb/hcd-ehci.c
===================================================================
--- qemu-2.0.0+dfsg.orig/hw/usb/hcd-ehci.c	2016-05-10 14:57:55.660705784 -0400
+++ qemu-2.0.0+dfsg/hw/usb/hcd-ehci.c	2016-05-10 14:57:55.612705149 -0400
@@ -2089,6 +2089,7 @@
 static void ehci_advance_state(EHCIState *ehci, int async)
 {
     EHCIQueue *q = NULL;
+    int itd_count = 0;
     int again;
 
     do {
@@ -2113,10 +2114,12 @@
 
         case EST_FETCHITD:
             again = ehci_state_fetchitd(ehci, async);
+            itd_count++;
             break;
 
         case EST_FETCHSITD:
             again = ehci_state_fetchsitd(ehci, async);
+            itd_count++;
             break;
 
         case EST_ADVANCEQUEUE:
@@ -2165,7 +2168,8 @@
             break;
         }
 
-        if (again < 0) {
+        if (again < 0 || itd_count > 16) {
+            /* TODO: notify guest (raise HSE irq?) */
             fprintf(stderr, "processing error - resetting ehci HC\n");
             ehci_reset(ehci);
             again = 0;
