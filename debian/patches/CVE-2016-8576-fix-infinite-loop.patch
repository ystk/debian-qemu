Description: xhci: limit the number of link trbs we are willing to process
 Needed to avoid we run in circles forever in case the guest builds
 an endless loop with link trbs.
Origin: upstream, http://git.qemu.org/?p=qemu.git;a=commit;h=05f43d44e4bc26611ce25fd7d726e483f73363ce
Bug-Debian: https://bugs.debian.org/840343
Index: qemu/hw/usb/hcd-xhci.c
===================================================================
--- qemu.orig/hw/usb/hcd-xhci.c
+++ qemu/hw/usb/hcd-xhci.c
@@ -52,6 +52,8 @@
  * to the specs when it gets them */
 #define ER_FULL_HACK
 
+#define TRB_LINK_LIMIT  4
+
 #define LEN_CAP         0x40
 #define LEN_OPER        (0x400 + 0x10 * MAXPORTS)
 #define LEN_RUNTIME     ((MAXINTRS + 1) * 0x20)
@@ -994,6 +996,8 @@ static TRBType xhci_ring_fetch(XHCIState
 {
     PCIDevice *pci_dev = PCI_DEVICE(xhci);
 
+    uint32_t link_cnt = 0;
+
     while (1) {
         TRBType type;
         pci_dma_read(pci_dev, ring->dequeue, trb, TRB_SIZE);
@@ -1019,6 +1023,9 @@ static TRBType xhci_ring_fetch(XHCIState
             ring->dequeue += TRB_SIZE;
             return type;
         } else {
+            if (++link_cnt > TRB_LINK_LIMIT) {
+                return 0;
+            }
             ring->dequeue = xhci_mask64(trb->parameter);
             if (trb->control & TRB_LK_TC) {
                 ring->ccs = !ring->ccs;
@@ -1036,6 +1043,7 @@ static int xhci_ring_chain_length(XHCISt
     bool ccs = ring->ccs;
     /* hack to bundle together the two/three TDs that make a setup transfer */
     bool control_td_set = 0;
+    uint32_t link_cnt = 0;
 
     while (1) {
         TRBType type;
@@ -1051,6 +1059,9 @@ static int xhci_ring_chain_length(XHCISt
         type = TRB_TYPE(trb);
 
         if (type == TR_LINK) {
+            if (++link_cnt > TRB_LINK_LIMIT) {
+                return -length;
+            }
             dequeue = xhci_mask64(trb.parameter);
             if (trb.control & TRB_LK_TC) {
                 ccs = !ccs;
