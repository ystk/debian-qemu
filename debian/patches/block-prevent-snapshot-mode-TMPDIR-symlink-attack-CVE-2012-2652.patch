Commit: eba25057b9a5e19d10ace2bc7716667a31297169
Author: Jim Meyering <jim@meyering.net>
Date:   Mon May 28 09:27:54 2012 +0200
Subject: block: prevent snapshot mode $TMPDIR symlink attack
Bug-Debian: http://bugs.debian.org/678280
Comment: backported to 0.12 by Michael Tokarev
    
    In snapshot mode, bdrv_open creates an empty temporary file without
    checking for mkstemp or close failure, and ignoring the possibility
    of a buffer overrun given a surprisingly long $TMPDIR.
    Change the get_tmp_filename function to return int (not void),
    so that it can inform its two callers of those failures.
    Also avoid the risk of buffer overrun and do not ignore mkstemp
    or close failure.
    Update both callers (in block.c and vvfat.c) to propagate
    temp-file-creation failure to their callers.
    
    get_tmp_filename creates and closes an empty file, while its
    callers later open that presumed-existing file with O_CREAT.
    The problem was that a malicious user could provoke mkstemp failure
    and race to create a symlink with the selected temporary file name,
    thus causing the qemu process (usually root owned) to open through
    the symlink, overwriting an attacker-chosen file.
    
    This addresses CVE-2012-2652.
    http://bugzilla.redhat.com/CVE-2012-2652
    
    Reviewed-by: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>
    Signed-off-by: Jim Meyering <meyering@redhat.com>
    Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>

--- a/block.c
+++ b/block.c
@@ -205,28 +205,36 @@ int bdrv_create(BlockDriver *drv, const
     return drv->bdrv_create(filename, options);
 }
 
-#ifdef _WIN32
-void get_tmp_filename(char *filename, int size)
+/*
+ * Create a uniquely-named empty temporary file.
+ * Return 0 upon success, otherwise a negative errno value.
+ */
+int get_tmp_filename(char *filename, int size)
 {
+#ifdef _WIN32
     char temp_dir[MAX_PATH];
-
-    GetTempPath(MAX_PATH, temp_dir);
-    GetTempFileName(temp_dir, "qem", 0, filename);
-}
+    /* GetTempFileName requires that its output buffer (4th param)
+       have length MAX_PATH or greater.  */
+    assert(size >= MAX_PATH);
+    return (GetTempPath(MAX_PATH, temp_dir)
+            && GetTempFileName(temp_dir, "qem", 0, filename)
+            ? 0 : -GetLastError());
 #else
-void get_tmp_filename(char *filename, int size)
-{
     int fd;
     const char *tmpdir;
-    /* XXX: race condition possible */
     tmpdir = getenv("TMPDIR");
     if (!tmpdir)
         tmpdir = "/tmp";
-    snprintf(filename, size, "%s/vl.XXXXXX", tmpdir);
+    if (snprintf(filename, size, "%s/vl.XXXXXX", tmpdir) >= size) {
+        return -EOVERFLOW;
+    }
     fd = mkstemp(filename);
-    close(fd);
-}
+    if (fd < 0 || close(fd)) {
+        return -errno;
+    }
+    return 0;
 #endif
+}
 
 #ifdef _WIN32
 static int is_windows_drive_prefix(const char *filename)
@@ -390,7 +398,10 @@ int bdrv_open2(BlockDriverState *bs, con
 
         bdrv_delete(bs1);
 
-        get_tmp_filename(tmp_filename, sizeof(tmp_filename));
+        ret = get_tmp_filename(tmp_filename, sizeof(tmp_filename));
+        if (ret < 0) {
+            return ret;
+        }
 
         /* Real path is meaningless for protocols */
         if (is_protocol)
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -2776,13 +2776,19 @@ static int enable_write_target(BDRVVVFAT
 {
     BlockDriver *bdrv_qcow;
     QEMUOptionParameter *options;
+    int ret;
     int size = sector2cluster(s, s->sector_count);
     s->used_clusters = calloc(size, 1);
 
     array_init(&(s->commits), sizeof(commit_t));
 
     s->qcow_filename = qemu_malloc(1024);
-    get_tmp_filename(s->qcow_filename, 1024);
+    ret = get_tmp_filename(s->qcow_filename, 1024);
+    if (ret < 0) {
+        qemu_free(s->qcow_filename);
+        s->qcow_filename = NULL;
+        return ret;
+    }
 
     bdrv_qcow = bdrv_find_format("qcow");
     options = parse_option_parameters("", bdrv_qcow->create_options, NULL);
--- a/block_int.h
+++ b/block_int.h
@@ -184,7 +184,7 @@ struct BlockDriverAIOCB {
     BlockDriverAIOCB *next;
 };
 
-void get_tmp_filename(char *filename, int size);
+int get_tmp_filename(char *filename, int size);
 
 void *qemu_aio_get(AIOPool *pool, BlockDriverState *bs,
                    BlockDriverCompletionFunc *cb, void *opaque);
